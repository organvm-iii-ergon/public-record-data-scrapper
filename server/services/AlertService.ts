/**
 * AlertService
 *
 * Service layer for the DEWS (Distressed Early Warning System) alert management.
 * Monitors prospect health thresholds, UCC filings, and payment events to generate
 * actionable alerts for portfolio managers.
 *
 * @module server/services/AlertService
 */

import { database } from '../database/connection'

/**
 * Types of alerts that can be generated by the DEWS system.
 */
export type AlertType =
  | 'health_drop'
  | 'new_ucc'
  | 'payment_missed'
  | 'score_critical'
  | 'trend_declining'

/**
 * Actions that can be taken when an alert is triggered.
 */
export type AlertAction = 'email' | 'sms' | 'webhook' | 'in_app'

/**
 * Alert severity levels.
 */
export type AlertSeverity = 'low' | 'medium' | 'high' | 'critical'

/**
 * Alert status values.
 */
export type AlertStatus = 'active' | 'acknowledged' | 'resolved' | 'dismissed'

/**
 * Rule defining when alerts should be triggered.
 */
export interface AlertRule {
  /** Unique identifier for the rule */
  id: string
  /** Organization that owns this rule */
  orgId: string
  /** Type of condition that triggers the alert */
  type: AlertType
  /** Threshold value for triggering (meaning depends on type) */
  threshold: number
  /** How to notify when triggered */
  action: AlertAction
  /** Severity level assigned to alerts from this rule */
  severity: AlertSeverity
  /** Whether this rule is active */
  enabled: boolean
  /** Optional: Only apply to specific prospects */
  prospectIds?: string[]
  /** Webhook URL if action is 'webhook' */
  webhookUrl?: string
  /** Additional configuration for the rule */
  config?: Record<string, unknown>
  /** When the rule was created */
  createdAt: string
  /** When the rule was last updated */
  updatedAt: string
}

/**
 * Alert entity representing a triggered warning.
 */
export interface Alert {
  /** Unique identifier */
  id: string
  /** Organization ID */
  orgId: string
  /** Rule that triggered this alert (null if ad-hoc) */
  ruleId?: string
  /** Prospect that triggered the alert */
  prospectId: string
  /** Type of alert */
  type: AlertType
  /** Severity level */
  severity: AlertSeverity
  /** Current status */
  status: AlertStatus
  /** Alert title */
  title: string
  /** Detailed message */
  message: string
  /** Additional context data */
  data: Record<string, unknown>
  /** When the alert was created */
  createdAt: string
  /** When the alert was acknowledged */
  acknowledgedAt?: string
  /** User who acknowledged */
  acknowledgedBy?: string
  /** When the alert was resolved */
  resolvedAt?: string
  /** User who resolved */
  resolvedBy?: string
  /** Resolution notes */
  resolutionNotes?: string
}

/**
 * Parameters for creating a new alert.
 */
export interface CreateAlertParams {
  orgId: string
  prospectId: string
  type: AlertType
  severity?: AlertSeverity
  title: string
  message: string
  data?: Record<string, unknown>
  ruleId?: string
}

/**
 * Parameters for listing alerts.
 */
export interface ListAlertsParams {
  orgId: string
  status?: AlertStatus | AlertStatus[]
  type?: AlertType
  severity?: AlertSeverity
  prospectId?: string
  limit?: number
  offset?: number
}

/**
 * Health threshold check result.
 */
export interface HealthCheckResult {
  prospectId: string
  currentScore: number
  previousScore?: number
  scoreDrop?: number
  triggeredRules: AlertRule[]
  alertsCreated: Alert[]
}

/**
 * Service for managing DEWS (Distressed Early Warning System) alerts.
 *
 * Provides methods for:
 * - Checking health thresholds and triggering alerts
 * - Creating and managing alerts
 * - Configuring alert rules
 * - Retrieving alert history
 *
 * @example
 * ```typescript
 * const service = new AlertService()
 *
 * // Check health thresholds for a prospect
 * const alerts = await service.checkHealthThresholds('prospect-123')
 *
 * // Get active alerts for an organization
 * const activeAlerts = await service.getActiveAlerts('org-456')
 *
 * // Acknowledge an alert
 * await service.acknowledgeAlert('alert-789', 'user-001')
 * ```
 */
export class AlertService {
  /**
   * Check health thresholds for a prospect and generate alerts if needed.
   *
   * Evaluates all enabled alert rules for the organization and creates
   * alerts for any triggered conditions.
   *
   * @param prospectId - The prospect's unique identifier
   * @returns Array of alerts generated from threshold checks
   */
  async checkHealthThresholds(prospectId: string): Promise<Alert[]> {
    // Get the prospect's current and previous health scores
    const healthQuery = `
      SELECT
        p.id as prospect_id,
        p.org_id,
        p.company_name,
        h1.health_score as current_score,
        h1.health_grade as current_grade,
        h2.health_score as previous_score,
        h2.health_grade as previous_grade
      FROM prospects p
      LEFT JOIN LATERAL (
        SELECT health_score, health_grade
        FROM portfolio_health_history
        WHERE prospect_id = p.id
        ORDER BY recorded_at DESC
        LIMIT 1
      ) h1 ON true
      LEFT JOIN LATERAL (
        SELECT health_score, health_grade
        FROM portfolio_health_history
        WHERE prospect_id = p.id
        ORDER BY recorded_at DESC
        LIMIT 1 OFFSET 1
      ) h2 ON true
      WHERE p.id = $1
    `

    const results = await database.query<{
      prospect_id: string
      org_id: string
      company_name: string
      current_score: number | null
      current_grade: string | null
      previous_score: number | null
      previous_grade: string | null
    }>(healthQuery, [prospectId])

    if (results.length === 0) {
      return []
    }

    const prospect = results[0]

    // If no health history, nothing to check
    if (prospect.current_score === null) {
      return []
    }

    // Get enabled rules for this organization
    const rules = await this.getEnabledRules(prospect.org_id)

    const alerts: Alert[] = []

    for (const rule of rules) {
      // Check if rule applies to this prospect
      if (rule.prospectIds && rule.prospectIds.length > 0) {
        if (!rule.prospectIds.includes(prospectId)) {
          continue
        }
      }

      let shouldAlert = false
      let alertTitle = ''
      let alertMessage = ''
      const alertData: Record<string, unknown> = {
        currentScore: prospect.current_score,
        previousScore: prospect.previous_score,
        threshold: rule.threshold
      }

      switch (rule.type) {
        case 'health_drop':
          // Check if health score dropped by more than threshold
          if (prospect.previous_score !== null) {
            const drop = prospect.previous_score - prospect.current_score
            if (drop >= rule.threshold) {
              shouldAlert = true
              alertTitle = `Health score dropped by ${drop} points`
              alertMessage = `${prospect.company_name}'s health score dropped from ${prospect.previous_score} to ${prospect.current_score}`
              alertData.scoreDrop = drop
            }
          }
          break

        case 'score_critical':
          // Check if score is below critical threshold
          if (prospect.current_score <= rule.threshold) {
            shouldAlert = true
            alertTitle = `Health score critically low: ${prospect.current_score}`
            alertMessage = `${prospect.company_name}'s health score (${prospect.current_score}) is below the critical threshold of ${rule.threshold}`
          }
          break

        case 'trend_declining':
          // Check for sustained declining trend (would need more history in production)
          if (
            prospect.previous_score !== null &&
            prospect.current_score < prospect.previous_score
          ) {
            const drop = prospect.previous_score - prospect.current_score
            if (drop >= rule.threshold) {
              shouldAlert = true
              alertTitle = `Declining health trend detected`
              alertMessage = `${prospect.company_name} shows a declining health trend (${prospect.previous_score} -> ${prospect.current_score})`
            }
          }
          break
      }

      if (shouldAlert) {
        const alert = await this.createAlert({
          orgId: prospect.org_id,
          prospectId,
          type: rule.type,
          severity: rule.severity,
          title: alertTitle,
          message: alertMessage,
          data: alertData,
          ruleId: rule.id
        })
        alerts.push(alert)

        // Execute the action (email, SMS, webhook)
        await this.executeAlertAction(alert, rule)
      }
    }

    return alerts
  }

  /**
   * Create a new alert.
   *
   * @param params - Alert creation parameters
   * @returns The created alert
   */
  async createAlert(params: CreateAlertParams): Promise<Alert> {
    const {
      orgId,
      prospectId,
      type,
      severity = 'medium',
      title,
      message,
      data = {},
      ruleId
    } = params

    const id = crypto.randomUUID()
    const now = new Date().toISOString()

    // STUB: In production, this would insert into database
    // const query = `
    //   INSERT INTO alerts (id, org_id, prospect_id, rule_id, type, severity, status, title, message, data, created_at)
    //   VALUES ($1, $2, $3, $4, $5, $6, 'active', $7, $8, $9, $10)
    //   RETURNING *
    // `

    const alert: Alert = {
      id,
      orgId,
      prospectId,
      ruleId,
      type,
      severity,
      status: 'active',
      title,
      message,
      data,
      createdAt: now
    }

    console.log(`[AlertService] Created alert: ${title} (${type}, ${severity})`)
    return alert
  }

  /**
   * Get all active alerts for an organization.
   *
   * @param orgId - The organization's unique identifier
   * @returns Array of active alerts
   */
  async getActiveAlerts(orgId: string): Promise<Alert[]> {
    // STUB: In production, this would query the database
    // const query = `
    //   SELECT *
    //   FROM alerts
    //   WHERE org_id = $1 AND status = 'active'
    //   ORDER BY
    //     CASE severity WHEN 'critical' THEN 1 WHEN 'high' THEN 2 WHEN 'medium' THEN 3 ELSE 4 END,
    //     created_at DESC
    // `

    console.log(`[AlertService] Getting active alerts for org: ${orgId}`)

    // Return empty array for stub
    return []
  }

  /**
   * Acknowledge an alert.
   *
   * @param alertId - The alert's unique identifier
   * @param userId - The user acknowledging the alert
   */
  async acknowledgeAlert(alertId: string, userId?: string): Promise<void> {
    const now = new Date().toISOString()

    // STUB: In production, this would update the database
    // const query = `
    //   UPDATE alerts
    //   SET status = 'acknowledged', acknowledged_at = $2, acknowledged_by = $3
    //   WHERE id = $1
    // `

    console.log(
      `[AlertService] Acknowledged alert ${alertId} by user ${userId || 'system'} at ${now}`
    )
  }

  /**
   * Resolve an alert with optional notes.
   *
   * @param alertId - The alert's unique identifier
   * @param userId - The user resolving the alert
   * @param notes - Optional resolution notes
   */
  async resolveAlert(alertId: string, userId?: string, notes?: string): Promise<void> {
    const now = new Date().toISOString()

    // STUB: In production, this would update the database
    // const query = `
    //   UPDATE alerts
    //   SET status = 'resolved', resolved_at = $2, resolved_by = $3, resolution_notes = $4
    //   WHERE id = $1
    // `

    console.log(`[AlertService] Resolved alert ${alertId} by user ${userId || 'system'} at ${now}`)
    if (notes) {
      console.log(`[AlertService] Resolution notes: ${notes}`)
    }
  }

  /**
   * Dismiss an alert (mark as not requiring action).
   *
   * @param alertId - The alert's unique identifier
   * @param userId - The user dismissing the alert
   */
  async dismissAlert(alertId: string, userId?: string): Promise<void> {
    // STUB: In production, this would update the database
    // const query = `
    //   UPDATE alerts
    //   SET status = 'dismissed', resolved_at = NOW(), resolved_by = $2, resolution_notes = 'Dismissed'
    //   WHERE id = $1
    // `

    console.log(`[AlertService] Dismissed alert ${alertId} by user ${userId || 'system'}`)
  }

  /**
   * Get alert history for a prospect.
   *
   * @param prospectId - The prospect's unique identifier
   * @param limit - Maximum number of alerts to return (default 50)
   * @returns Array of historical alerts
   */
  async getAlertHistory(prospectId: string, limit: number = 50): Promise<Alert[]> {
    // STUB: In production, this would query the database
    // const query = `
    //   SELECT *
    //   FROM alerts
    //   WHERE prospect_id = $1
    //   ORDER BY created_at DESC
    //   LIMIT $2
    // `

    console.log(`[AlertService] Getting alert history for prospect: ${prospectId}, limit: ${limit}`)

    // Return empty array for stub
    return []
  }

  /**
   * List alerts with filtering and pagination.
   *
   * @param params - List parameters
   * @returns Paginated array of alerts
   */
  async listAlerts(params: ListAlertsParams): Promise<{ alerts: Alert[]; total: number }> {
    const { orgId, status, type, severity, prospectId, limit = 50, offset = 0 } = params

    // STUB: In production, this would build and execute a dynamic query
    console.log(`[AlertService] Listing alerts for org: ${orgId}`, {
      status,
      type,
      severity,
      prospectId,
      limit,
      offset
    })

    return { alerts: [], total: 0 }
  }

  /**
   * Create or update an alert rule.
   *
   * @param rule - The rule to create or update
   * @returns The saved rule
   */
  async saveRule(
    rule: Omit<AlertRule, 'createdAt' | 'updatedAt'> & { id?: string }
  ): Promise<AlertRule> {
    const now = new Date().toISOString()
    const id = rule.id || crypto.randomUUID()

    // STUB: In production, this would upsert into the database
    const savedRule: AlertRule = {
      ...rule,
      id,
      createdAt: now,
      updatedAt: now
    }

    console.log(`[AlertService] Saved rule: ${savedRule.type} (threshold: ${savedRule.threshold})`)
    return savedRule
  }

  /**
   * Get enabled rules for an organization.
   *
   * @param orgId - The organization's unique identifier
   * @returns Array of enabled alert rules
   */
  async getEnabledRules(orgId: string): Promise<AlertRule[]> {
    // STUB: In production, this would query the database
    // const query = `
    //   SELECT *
    //   FROM alert_rules
    //   WHERE org_id = $1 AND enabled = true
    //   ORDER BY type, threshold
    // `

    console.log(`[AlertService] Getting enabled rules for org: ${orgId}`)

    // Return default rules for stub implementation
    const now = new Date().toISOString()
    return [
      {
        id: 'default-health-drop',
        orgId,
        type: 'health_drop',
        threshold: 15,
        action: 'in_app',
        severity: 'high',
        enabled: true,
        createdAt: now,
        updatedAt: now
      },
      {
        id: 'default-score-critical',
        orgId,
        type: 'score_critical',
        threshold: 40,
        action: 'email',
        severity: 'critical',
        enabled: true,
        createdAt: now,
        updatedAt: now
      }
    ]
  }

  /**
   * Delete an alert rule.
   *
   * @param ruleId - The rule's unique identifier
   */
  async deleteRule(ruleId: string): Promise<void> {
    // STUB: In production, this would delete from the database
    console.log(`[AlertService] Deleted rule: ${ruleId}`)
  }

  /**
   * Configure alert rules for an organization.
   *
   * Bulk update/replace alert rules for an organization. This method
   * replaces all existing rules with the provided set.
   *
   * @param orgId - The organization's unique identifier
   * @param rules - Array of alert rules to configure
   * @returns The configured rules with generated IDs
   */
  async configureAlertRules(
    orgId: string,
    rules: Array<Omit<AlertRule, 'id' | 'orgId' | 'createdAt' | 'updatedAt'>>
  ): Promise<AlertRule[]> {
    const now = new Date().toISOString()

    // STUB: In production, this would:
    // 1. Begin a transaction
    // 2. Delete all existing rules for the org
    // 3. Insert the new rules
    // 4. Commit the transaction

    const configuredRules: AlertRule[] = rules.map((rule, index) => ({
      ...rule,
      id: `rule-${orgId}-${index}-${Date.now()}`,
      orgId,
      createdAt: now,
      updatedAt: now
    }))

    console.log(`[AlertService] Configured ${configuredRules.length} rules for org: ${orgId}`)

    for (const rule of configuredRules) {
      console.log(
        `  - ${rule.type}: threshold=${rule.threshold}, action=${rule.action}, severity=${rule.severity}`
      )
    }

    return configuredRules
  }

  /**
   * Execute the alert action (send notification).
   *
   * @param alert - The alert to notify about
   * @param rule - The rule that triggered the alert
   */
  private async executeAlertAction(alert: Alert, rule: AlertRule): Promise<void> {
    switch (rule.action) {
      case 'email':
        console.log(`[AlertService] STUB: Would send email for alert: ${alert.title}`)
        // In production: await sendGridClient.send({ ... })
        break

      case 'sms':
        console.log(`[AlertService] STUB: Would send SMS for alert: ${alert.title}`)
        // In production: await twilioClient.sendSms({ ... })
        break

      case 'webhook':
        if (rule.webhookUrl) {
          console.log(
            `[AlertService] STUB: Would POST to webhook ${rule.webhookUrl} for alert: ${alert.title}`
          )
          // In production: await fetch(rule.webhookUrl, { method: 'POST', body: JSON.stringify(alert) })
        }
        break

      case 'in_app':
        console.log(`[AlertService] In-app notification for alert: ${alert.title}`)
        // In-app notifications are handled by the frontend polling getActiveAlerts
        break
    }
  }

  /**
   * Record a new health score and check thresholds.
   *
   * Convenience method that records a health score and then checks
   * if any alerts should be triggered.
   *
   * @param prospectId - The prospect's unique identifier
   * @param score - The health score (0-100)
   * @param factors - Contributing factors
   * @returns Any alerts that were generated
   */
  async recordHealthAndCheck(
    prospectId: string,
    score: number,
    factors?: Record<string, unknown>
  ): Promise<Alert[]> {
    // Record the health score
    const insertQuery = `
      INSERT INTO portfolio_health_history (prospect_id, health_score, factors, source)
      VALUES ($1, $2, $3, 'system')
      RETURNING id
    `

    try {
      await database.query(insertQuery, [
        prospectId,
        score,
        factors ? JSON.stringify(factors) : null
      ])
      console.log(`[AlertService] Recorded health score ${score} for prospect ${prospectId}`)
    } catch (error) {
      console.error(`[AlertService] Failed to record health score:`, error)
      // Continue to check thresholds even if recording failed
    }

    // Check if any alerts should be triggered
    return this.checkHealthThresholds(prospectId)
  }
}

/**
 * Default AlertService instance
 */
export const alertService = new AlertService()
